// Copyright (c) 2021 Milan Raj
// SPDX-License-Identifier: MIT

// exprtkcore generated by emscripten with named default export
// eslint-disable-next-line import/no-named-as-default, import/no-named-as-default-member
import exprtkcore from '../dist/exprtkcore.js';

// Make sure to use Module.stackSave() before calling
const writeStringToStack = function (Module, str) {
    // Algorithm from emscripten ccall toC string
    // eslint-disable-next-line no-bitwise
    const strMaxStackLength = (str.length << 2) + 1;
    const strStackPointer = Module.stackAlloc(strMaxStackLength);
    Module.stringToUTF8(str, strStackPointer, strMaxStackLength);
    return strStackPointer;
};

class Variable {
    constructor (Module, symbolTableRef, name) {
        const variableRef = Module._malloc(8);
        if (variableRef === 0) {
            throw new Error(`Not enough memory to allocate variable ${name}.`);
        }
        const stack = Module.stackSave();
        const nameRef = writeStringToStack(Module, name);
        const result = Module._SymbolTable_AddVariable(symbolTableRef, nameRef, variableRef);
        Module.stackRestore(stack);
        Module.exprtkcore.flush();
        if (!result) {
            throw new Error(`Failed to create variable with name ${name}`);
        }
        this._Module = Module;
        this._variableRef = variableRef;
    }

    destroy () {
        this._Module._free(this._variableRef);
        this._variableRef = undefined;
        this._Module = undefined;
    }

    set value (number) {
        this._Module.HEAPF64[this._variableRef / 8] = number;
    }

    get value () {
        return this._Module.HEAPF64[this._variableRef / 8];
    }
}

class Vector {
    constructor (Module, symbolTableRef, name, size) {
        const vectorRef = Module._malloc(size * 8);
        if (vectorRef === 0) {
            throw new Error(`Not enough memory to allocate vector ${name} with size ${size}.`);
        }
        const stack = Module.stackSave();
        const nameRef = writeStringToStack(Module, name);
        const result = Module._SymbolTable_AddVector(symbolTableRef, nameRef, vectorRef, size);
        Module.stackRestore(stack);
        Module.exprtkcore.flush();
        if (!result) {
            throw new Error(`Failed to create vector with name ${name}`);
        }
        this._Module = Module;
        this._vectorRef = vectorRef;
        this._size = size;
    }

    destroy () {
        this._Module._free(this._vectorRef);
        this._vectorRef = undefined;
        this._size = undefined;
        this._Module = undefined;
    }

    // Only valid until before another function used. DO NO SAVE REFERENCE.
    // Memory growth due to function execution will invalidate buffer.
    createBufferView () {
        return new Float64Array(this._Module.HEAPF64.buffer, this._vectorRef, this._size);
    }

    assign (arrayLike) {
        for (let i = this._vectorRef / 8; i < this._size; i++) {
            this._Module.HEAPF64[i] = arrayLike[i];
        }
    }
}

class SymbolTable {
    constructor (Module) {
        this._Module = Module;
        this._symbolTableRef = this._Module._SymbolTable_Create();
        this._packageIORef = undefined;
        this._packageVecopsRef = undefined;
        this._packageArmadilloRef = undefined;
        this._packageSigpackRef = undefined;
        this._Module.exprtkcore.flush();
    }

    destroy () {
        this._Module._SymbolTable_Destroy(this._symbolTableRef);
        this._symbolTableRef = undefined;
        if (this._packageIORef) {
            this._Module._PackageIO_Destroy(this._packageIORef);
            this._packageIORef = undefined;
        }
        if (this._packageVecopsRef) {
            this._Module._PackageVecops_Destroy(this._packageVecopsRef);
            this._packageVecopsRef = undefined;
        }
        if (this._packageArmadilloRef) {
            this._Module._PackageArmadillo_Destroy(this._packageArmadilloRef);
            this._packageArmadilloRef = undefined;
        }
        if (this._packageSigpackRef) {
            this._Module._PackageSigpack_Destroy(this._packageSigpackRef);
            this._packageSigpackRef = undefined;
        }
        this._Module.exprtkcore.flush();
        this._Module = undefined;
    }

    addConstants () {
        const result = this._Module._SymbolTable_AddConstants(this._symbolTableRef);
        this._Module.exprtkcore.flush();
        if (!result) {
            throw new Error('Failed to add constants to symbol table');
        }
    }

    addPackageIO () {
        if (this._packageIORef) {
            throw new Error('Package IO already defined in symbol table');
        }
        this._packageIORef = this._Module._PackageIO_Create();
        const result = this._Module._SymbolTable_AddPackageIO(this._symbolTableRef, this._packageIORef);
        this._Module.exprtkcore.flush();
        if (!result) {
            this._Module._PackageIO_Destroy(this._packageIORef);
            this._packageIORef = undefined;
            throw new Error('Failed to add package IO to symbol table');
        }
    }

    addPackageVecops () {
        if (this._packageVecopsRef) {
            throw new Error('Package Vecops already defined in symbol table');
        }
        this._packageVecopsRef = this._Module._PackageVecops_Create();
        const result = this._Module._SymbolTable_AddPackageVecops(this._symbolTableRef, this._packageVecopsRef);
        this._Module.exprtkcore.flush();
        if (!result) {
            this._Module._PackageVecops_Destroy(this._packageVecopsRef);
            this._packageVecopsRef = undefined;
            throw new Error('Failed to add package Vecops to symbol table');
        }
    }

    addPackageArmadillo () {
        if (this._packageArmadilloRef) {
            throw new Error('Package Armadillo already defined in symbol table');
        }
        this._packageArmadilloRef = this._Module._PackageArmadillo_Create();
        const result = this._Module._SymbolTable_AddPackageArmadillo(this._symbolTableRef, this._packageArmadilloRef);
        this._Module.exprtkcore.flush();
        if (!result) {
            this._Module._PackageAramadillo_Destroy(this._packageArmadilloRef);
            this._packageArmadilloRef = undefined;
            throw new Error('Failed to add package Armadillo to symbol table');
        }
    }

    addPackageSigpack () {
        if (this._packageSigpackRef) {
            throw new Error('Package Sigpack already defined in symbol table');
        }
        this._packageSigpackRef = this._Module._PackageSigpack_Create();
        const result = this._Module._SymbolTable_AddPackageSigpack(this._symbolTableRef, this._packageSigpackRef);
        this._Module.exprtkcore.flush();
        if (!result) {
            this._Module._PackageSigpack_Destroy(this._packageSigpackRef);
            this._packageSigpackRef = undefined;
            throw new Error('Failed to add package Sigpack to symbol table');
        }
    }

    createVariable (name) {
        return new Variable(this._Module, this._symbolTableRef, name);
    }

    createVector (name, size) {
        return new Vector(this._Module, this._symbolTableRef, name, size);
    }
}

class Expression {
    constructor (Module) {
        this._Module = Module;
        this._expressionRef = this._Module._Expression_Create();
        this._Module.exprtkcore.flush();
    }

    destroy () {
        this._Module._Expression_Destroy(this._expressionRef);
        this._Module.exprtkcore.flush();
        this._expressionRef = undefined;
        this._Module = undefined;
    }

    registerSymbolTable (symbolTable) {
        this._Module._Expression_RegisterSymbolTable(this._expressionRef, symbolTable._symbolTableRef);
        this._Module.exprtkcore.flush();
    }

    value () {
        const ret = this._Module._Expression_Value(this._expressionRef);
        this._Module.exprtkcore.flush();
        return ret;
    }
}

class Parser {
    constructor (Module) {
        this._Module = Module;
        this._parserRef = this._Module._Parser_Create();
        this._Module.exprtkcore.flush();
    }

    destroy () {
        this._Module._Parser_Destroy(this._parserRef);
        this._Module.exprtkcore.flush();
        this._parserRef = undefined;
        this._Module = undefined;
    }

    compile (str, expression) {
        const stack = this._Module.stackSave();
        const strRef = writeStringToStack(this._Module, str);
        const result = this._Module._Parser_Compile(this._parserRef, strRef, expression._expressionRef);
        this._Module.stackRestore(stack);
        this._Module.exprtkcore.flush();
        if (!result) {
            // TODO instead of printing should pass error in exception
            this._Module._Parser_PrintError(this._parserRef);
            this._Module.exprtkcore.flush();
            throw new Error(`Failed to compile expression: ${str}`);
        }
    }
}

class Exprtk {
    constructor (Module) {
        this._Module = Module;
    }

    destroy () {
        this._Module = undefined;
    }

    createSymbolTable () {
        return new SymbolTable(this._Module);
    }

    createExpression () {
        return new Expression(this._Module);
    }

    createParser () {
        return new Parser(this._Module);
    }
}

const createModule = function () {
    const Module = {};
    Module.arguments = ['--exit'];
    Module.exprtkcore = {
        ENVIRONMENT_IS_WEB: typeof window === 'object',
        ENVIRONMENT_IS_WORKER: typeof importScripts === 'function',
        ENVIRONMENT_IS_NODE: typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string',
        wasmUrl: '',
        flush: undefined
    };

    Module.locateFile = (path, prefix) => {
        if (path.endsWith('.wasm')) {
            return Module.exprtkcore.wasmUrl;
        }
        return prefix + path;
    };

    if (Module.exprtkcore.ENVIRONMENT_IS_NODE) {
        Module.quit = (_status, toThrow) => {
            throw toThrow;
        };
    }
    return Module;
};

export const createExprtk = async function () {
    const Module = await exprtkcore(createModule());
    const ret = new Exprtk(Module);
    Module.exprtkcore.flush();
    return ret;
};
